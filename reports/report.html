<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Amar Gill">
<meta name="dcterms.date" content="2025-04-15">

<title>Predicting League of Legends game outcomes: A comparison of Bayesian and Non-Bayesian methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Predicting League of Legends game outcomes: A comparison of Bayesian and Non-Bayesian methods</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Amar Gill </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="intro" class="level2">
<h2 class="anchored" data-anchor-id="intro">Intro</h2>
<p>League of Legends, a Multiplayer-Online-Battle-Arena (MOBA) pits five players, controlling champions, to destroy the enemies team’s nexus. Due to the nuances of the game, as well as unique and independent factors, no two games are unique. These factors and nuances include but not limited to: Champion selection, item build paths, rune choices and much more.</p>
<p>For our analysis, factors that are not strictly dependent on player skill were ignored. This choice is due to the fact that choices as listed above require a different skillset that is not improved by practice in the traditional matter. Our analysis focuses on gameplay aspects and markers that a player can tangibly see during and after the game. By determining the most critical factors using LASSO (Least Absolute Shrinkage and Selection Operator) and measuring the BIC (Bayesian Information Criterion) to compare models, we seek to answer which model predicts the outcome of a game more accurately.</p>
<p>In <span class="citation" data-cites="statsRethinking">McElreath (<a href="#ref-statsRethinking" role="doc-biblioref">2016;2015;2018;</a>)</span>, chapter 6 discusses the use of different criterion for model comparison, as well as discusses LASSO/Ridge. McElreath argues that LASSO/Ridge can be viewed as Bayesian/Non-Bayesian, depending on the perspective. Since it uses gaussian priors but it does not compute a posterior distribution, there is an argument for both. In our case, we are treating it as a non-Bayesian model to contrast against our STAN model.</p>
<p>For an in-depth analysis of the game as well as core mechanics, <span class="citation" data-cites="leaguePrediction">Hitar-Garcia, Moran-Fernandez, and Bolon-Canedo (<a href="#ref-leaguePrediction" role="doc-biblioref">2023</a>)</span> explains as well as goes in depth into their own prediction model. In their findings, they created new features from the result of given features in the data, and used player win rates in their calculations. Their goal is to predict a win before the game starts while our approach is to predict the outcome given data from the game. Both findings used different approaches for the same outcome, given different circumstances. Since League of Legends, is still relatively new, not much has been researched regarding key factors, as mentioned in <span class="citation" data-cites="leaguePrediction">Hitar-Garcia, Moran-Fernandez, and Bolon-Canedo (<a href="#ref-leaguePrediction" role="doc-biblioref">2023</a>)</span>. They describe two groups of approaches, with our findings taking account of in-game information, while their findings did not use it.</p>
</section>
<section id="analysis" class="level2">
<h2 class="anchored" data-anchor-id="analysis">Analysis</h2>
<p>The data was collected by a willing third-party who allowed their games to be used for this analysis. The data is a collection of 70 ranked solo/duo games played during split 1 of the 2024 season. These 70 games were played in the mid or top role, two of five possible roles in the game. For this analysis, the goals and expectations of the top and mid role are similar enough so that we can ignore any differences between them and consider them the same.</p>
<p>We model the binary outcome ( y_i {0, 1} ) (win/loss) using logistic regression:</p>
<p><span class="math display">\[\begin{align*}
y_i &amp;\sim \text{Bernoulli}(\pi_i), \quad i = 1, \dots, N \\
\beta_j &amp;\sim \mathcal{N}(0, \sigma^2) \quad \text{for all } j \in \{1, \dots, K\} \\
\text{logit}(\pi_i) &amp;= \mathbf{x}_i^\top \boldsymbol{\beta}
\end{align*}\]</span></p>
<p>For this logistic regression task predicting win/loss outcomes, we use priors to guard against overfitting and to stabilize estimation in the presence of multicollinearity or weak signals.</p>
<section id="choice-of-prior-β-normal0-1" class="level3">
<h3 class="anchored" data-anchor-id="choice-of-prior-β-normal0-1">🔹 Choice of Prior: <code>β ~ Normal(0, 1)</code></h3>
<p>We specify a <strong>weakly informative normal prior</strong>:</p>
<p><code>beta ~ normal(0, 1);</code></p>
<p>The choice of the standard normal is because we believe the large amount of data will affect the posterior more than the prior itself. I am not an expert in the field yet to choose an informative prior, so letting the data and it’s likelihood to determine the posterior is the safer choice.</p>
<p><code>y ~ bernoulli_logit(X * beta)</code></p>
<p>Bernoulli_logit was used since we are performing logistic regression on a binary outcome. It is the most naturally-fitting distribution for this project.</p>
<p>The full STAN code is available in the <a href="#stan-model">appendix</a>.</p>
<p>We <a href="#data-splitting">split the data</a> 70/30 for training and testing respectively, to use for accuracy testing done later.</p>
<p>Before running the STAN code, we use LASSO to perform feature selection. LASSO selects features that contribute significantly by minimizing penalties brought by overfitting, and only using the most significant features. By performing some EDA to remove unnecessary features, then performing LASSO, we can isolate the data before using it in our prediction models.</p>
<p>Data clean up as well as LASSO can be found <a href="#data-cleaning">in the appendix</a>.</p>
<p>After performing LASSO, the optimal value for <span class="math inline">\(\lambda\)</span> is found by plotting the cross validation generalized linear model object and determining the <span class="math inline">\(\lambda\)</span> with the lowest misclassification error. Both the <span class="math inline">\(\lambda_{min}\)</span> and <span class="math inline">\(\lambda_{1se}\)</span> both determine six coefficients are best for our data and specification.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="lassoLambda.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption>Figure 1: Misclassification Error against Lambda values</figcaption>
</figure>
</div>
<p>The six selected features were the following and a brief description along with them (follows the assumption <span class="citation" data-cites="leaguePrediction">Hitar-Garcia, Moran-Fernandez, and Bolon-Canedo (<a href="#ref-leaguePrediction" role="doc-biblioref">2023</a>)</span> is read previously for further understanding):</p>
<ul>
<li>Selected Features
<ul>
<li>Assists - When the player participates in the death of an enemy by dealing damage or aiding their ally who dealt the final blow</li>
<li>Inhibitor takedowns - When the player aids in the destruction of an enemy inhibitor</li>
<li>Kills - When the player deals the final blow of an enemy’s death</li>
<li>Largest killing spree - Largest number of consecutive kills without a player’s death occuring</li>
<li>Turret takedowns - Same as Inhibitor takedowns but for turrets</li>
<li>Turrets lost - The number of turrets the player’s team has lost due to the enemy</li>
</ul></li>
</ul>
<p>And these features make sense in the context of winning a game. Kills and assist are useful since when the enemy is dead, that gives an advantage for the player to do objectives or cash in their gold, becoming stronger. Largest killing spree is more interesting since it means the most kills without dying, and the player can impact the map if they are not dead. We are not considering a professional play environment, where factors such as kills and assists matter less. Professional players are able to create much larger advantages from fewer kills. In the ranked solo/duo games being analyzed here, kills and assists drive players to perform actions that create an advantage more so than professional play.</p>
<p>As for turrets and inhibitor takedowns, the game cannot end without them being destroyed so that is why they are favoured over non-mandatory objectives like Rift Heralds or Elemental Drakes, which are creatures found between lanes that can aid the team who kills them an advantage.</p>
<p>Turrets lost conversely is low when the player’s team is performing well enough that the enemy has no opportunity to damage and destroy them, signifying the player’s team having the advantage.</p>
<p>As mentioned <a href="#intro">earlier</a>, we used each model’s BIC for comparison. Since overfitting is a significant issue, penalizing more parameters being used limits the error overfitting would bring. Since both models are performing classification, it is simple to compare each number to one another and determine the better performing model.</p>
<p>After computing predicted probabilties for our test data and their log-likelihoods, we compute the following BIC’s for the <a href="#bic-calculation-for-lasso">LASSO</a> and <a href="#bic-calculation-for-stan">STAN</a> models:</p>
<p>(Due to inflation from MCMC samples, the use of <code>colMeans()</code> is employed and the use of the posterior mean is present.)</p>
<ul>
<li>BIC of the LASSO logistic regression model: 25.81679</li>
<li>Corrected BIC (using posterior mean): 22.98501</li>
</ul>
<p>Comparing the BIC’s, the STAN model achieves a lower value, yet still close to the LASSO model. So even though the STAN model has a lower BIC than the LASSO model, the LASSO model requires no prior to be chosen nor a STAN model to be created and ran. LASSO is also much faster to compute and is very efficient. Efficiency would matter a lot more if we had more data. This report only used 70 data points but in a game such as League of Legends, where millions of games are played weekly, using STAN will be difficult due to the resources it will consume. Another limitation of the data is that it is representative of the one player who’s data belongs to. It is not representative of the player base in it’s entirity, nor is it a fair sample of them. For future studies, compiling many players with perhaps different playstyles but in the same role, can determine more nuanced features that are significant to their success.</p>
</section>





</section>
<section id="references" class="level2 unnumbered">


</section>

<div id="quarto-appendix" class="default"><section id="stan-model" class="level3 appendix"><h2 class="anchored quarto-appendix-heading">Stan Model</h2><div class="quarto-appendix-contents">

<div class="cell" data-output.var="priors">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode stan code-with-copy"><code class="sourceCode stan"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; N;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>&gt; K;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">matrix</span>[N, K] X;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>&lt;<span class="kw">lower</span>=<span class="dv">0</span>,<span class="kw">upper</span>=<span class="dv">1</span>&gt; y[N];</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">parameters</span> {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">vector</span>[K] beta;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">model</span> {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  beta ~ normal(<span class="dv">0</span>, <span class="dv">1</span>);</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  y ~ bernoulli_logit(X * beta);</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div></section><section id="data-cleaning" class="level3 appendix"><h2 class="anchored quarto-appendix-heading">Data cleaning</h2><div class="quarto-appendix-contents">

<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Select numeric columns that sum to 0</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>droppedColumns <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">colnames</span>(<span class="fu">select_if</span>(data, is.numeric)))){</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    column <span class="ot">&lt;-</span> <span class="fu">toString</span>(<span class="fu">colnames</span>(<span class="fu">select_if</span>(data, is.numeric))[i])</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">sum</span>(data[column]) <span class="sc">==</span> <span class="dv">0</span>){</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        droppedColumns <span class="ot">&lt;-</span> <span class="fu">c</span>(droppedColumns, column)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="sc">-</span><span class="fu">c</span>(puuid, summonerName, riotIdGameName, riotIdTagline, summonerId, objectivesStolen, profileIcon, summoner1Id, nexusLost, nexusTakedowns))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> data[, <span class="sc">!</span><span class="fu">colnames</span>(data) <span class="sc">%in%</span> droppedColumns]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert 'win' to numeric (0/1)</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>win <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(data<span class="sc">$</span>win)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove character/factor columns</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>data_numeric <span class="ot">&lt;-</span> data <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="fu">where</span>(is.numeric))</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove rows with NA</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>data_numeric <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(data_numeric)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Split into predictors and response</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> data_numeric <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="sc">-</span>win) <span class="sc">%&gt;%</span> <span class="fu">as.matrix</span>()</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> data_numeric<span class="sc">$</span>win</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div></section><section id="data-splitting" class="level3 appendix"><h2 class="anchored quarto-appendix-heading">Data splitting</h2><div class="quarto-appendix-contents">

<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>train_index <span class="ot">&lt;-</span> <span class="fu">createDataPartition</span>(y, <span class="at">p =</span> <span class="fl">0.7</span>, <span class="at">list =</span> <span class="cn">FALSE</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>X_train <span class="ot">&lt;-</span> X[train_index, ]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>y_train <span class="ot">&lt;-</span> y[train_index]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>X_test <span class="ot">&lt;-</span> X[<span class="sc">-</span>train_index, ]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>y_test <span class="ot">&lt;-</span> y[<span class="sc">-</span>train_index]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div></section><section id="bic-calculation-for-lasso" class="level3 appendix"><h2 class="anchored quarto-appendix-heading">BIC calculation for LASSO</h2><div class="quarto-appendix-contents">

<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>n_test <span class="ot">&lt;-</span> <span class="fu">nrow</span>(X_test_scaled)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">sum</span>(lasso_coef[<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>] <span class="sc">!=</span> <span class="dv">0</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>pred_probs <span class="ot">&lt;-</span> <span class="fu">predict</span>(cvfit, <span class="at">newx =</span> X_test_scaled, <span class="at">s =</span> <span class="st">"lambda.min"</span>, <span class="at">type =</span> <span class="st">"response"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>pred_probs <span class="ot">&lt;-</span> <span class="fu">pmin</span>(<span class="fu">pmax</span>(pred_probs, <span class="fl">1e-15</span>), <span class="dv">1</span> <span class="sc">-</span> <span class="fl">1e-15</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>log_likelihood <span class="ot">&lt;-</span> <span class="fu">sum</span>(y_test <span class="sc">*</span> <span class="fu">log</span>(pred_probs) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">-</span> y_test) <span class="sc">*</span> <span class="fu">log</span>(<span class="dv">1</span> <span class="sc">-</span> pred_probs))</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>bic <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span> <span class="sc">*</span> log_likelihood <span class="sc">+</span> k <span class="sc">*</span> <span class="fu">log</span>(n_test)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"BIC of the LASSO logistic regression model:"</span>, bic, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div></section><section id="bic-calculation-for-stan" class="level3 appendix"><h2 class="anchored quarto-appendix-heading">BIC calculation for STAN</h2><div class="quarto-appendix-contents">

<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>beta_mean <span class="ot">&lt;-</span> <span class="fu">colMeans</span>(beta_post)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>mean_pred_probs <span class="ot">&lt;-</span> <span class="fu">plogis</span>(X_test_scaled <span class="sc">%*%</span> beta_mean)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>mean_pred_probs <span class="ot">&lt;-</span> <span class="fu">pmin</span>(<span class="fu">pmax</span>(mean_pred_probs, <span class="fl">1e-15</span>), <span class="dv">1</span> <span class="sc">-</span> <span class="fl">1e-15</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute log-likelihood</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>log_lik <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">ifelse</span>(y_test <span class="sc">==</span> <span class="dv">1</span>, <span class="fu">log</span>(mean_pred_probs), <span class="fu">log</span>(<span class="dv">1</span> <span class="sc">-</span> mean_pred_probs)))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute BIC</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="fu">length</span>(beta_mean)  <span class="co"># number of coefficients</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">length</span>(y_test)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>bic <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span> <span class="sc">*</span> log_lik <span class="sc">+</span> k <span class="sc">*</span> <span class="fu">log</span>(n)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Correct BIC (using posterior mean):"</span>, bic, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div></section><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-leaguePrediction" class="csl-entry" role="listitem">
Hitar-Garcia, Juan A., Laura Moran-Fernandez, and Veronica Bolon-Canedo. 2023. <span>“Machine Learning Methods for Predicting League of Legends Game Outcome.”</span> <em>IEEE Transactions on Games</em> 15 (2): 171–81.
</div>
<div id="ref-statsRethinking" class="csl-entry" role="listitem">
McElreath, Richard. 2016;2015;2018; <em>Statistical Rethinking: A Bayesian Course with Examples in r and Stan</em>. 1st;1st;1st; ed. Vol. 122. Boca Raton: CRC Press.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>